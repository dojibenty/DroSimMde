/*
 * DroneSweep.cpp
 *
 * Generated by Cares generator, written with Acceleo
 * Author: pyp
 */

#include "compDroneSweep.h"
#include "DroneSweep.h"

compDroneSweep::compDroneSweep(double aFrequency) : LeafComponent(aFrequency) {
    auto obj = new DroneSweep(this, 0);
    appli.emplace_back(obj);
    oldSweepposition.push_back(obj->getSweepposition());
    newSweepposition.push_back(obj->getSweepposition());
    delay = 0;
    delayMax = 0;
    newValue = false;
    isActive = true;
}

compDroneSweep::~compDroneSweep() {}

void compDroneSweep::doOneStep() {
    if (newValue) {
        delay++;
        if (delay == delayMax) {
            oldSweepposition = newSweepposition;
            newValue = false;
        }
    }
}

int compDroneSweep::doStep(int nStep) {
    if (newValue) {
        oldSweepposition = newSweepposition;
        newValue = false;
    }
    readInputs();
    const int numberOf = getNumberOf();
    vector<int> returnCodes;
    for (int i = 0; i < numberOf; i++) {
        if (status[i]) {
            returnCodes.push_back(-1);
            continue;
        }
        auto inst = appli[i];
        if (pauseCondition(inst)) {
            returnCodes.push_back(-1);
            continue;
        }
        returnCodes.push_back(inst->doStep(nStep));
        newSweepposition[i] = inst->getSweepposition();
    }

    if (delayMax == 0) {
        oldSweepposition = newSweepposition;
        newValue = false;
    }
    else {
        newValue = true;
        delay = 0;
    }

    return sendReturnCode(returnCodes);
}

int compDroneSweep::sendReturnCode(const vector<int>& returnCodes) {
    int code = 0;
    for (int i = 0; i < returnCodes.size(); i++) {
        switch (returnCodes[i]) {
        case 1:
            code = 1;
            break;
        case 2:
            status[i] = true;
            break;
        default:
            break;
        }
    }
    
    if (code == 1) return 1;
    
    for (int i = 0; i < status.size(); i++)
        if (!status[i]) return 0;

    return 2;
}

bool compDroneSweep::pauseCondition(DroneSweep* inst) {
    const double collisionRadius = inst->getCollisionRadius();
    for (DroneSweep* obj : appli)
        if (vect2::distance(inst->getPosition(), obj->getPosition()) <= collisionRadius)
            if (inst->getDroneID() < obj->getDroneID())
                return true;
    return false;
}

void compDroneSweep::updateNumberOfInstances(const unsigned int arg) {
    if (appli.size() == arg) return;
    if (appli.size() < arg) {
        auto obj = new DroneSweep(this, appli.size());
        appli.emplace_back(obj);
        oldSweepposition.push_back(obj->getSweepposition());
        newSweepposition.push_back(obj->getSweepposition());
        obj->setrItfGeoDataSweep(appli[0]->getItfGeoDataInterface());
        obj->setrItfManageSimSweep(appli[0]->getItfManageSimInterface());
        obj->setrItfSimDataSweep(appli[0]->getItfSimDataInterface());
        obj->setSpeed(appli[0]->getSpeed());
    }
    else {
        appli.pop_back();
        oldSweepposition.pop_back();
        newSweepposition.pop_back();
    }
}

void compDroneSweep::printInstRecap() {
    for (DroneSweep* obj : appli) {
        obj->printRecap();
    }
}

void compDroneSweep::readInputs() {}

void compDroneSweep::initialize() {
    for (int i = 0; i < getNumberOf(); i++) {
        appli[i]->initialize();
        status[i] = false;
    }
}

void compDroneSweep::end() {
    for (int i = 0; i < getNumberOf(); i++)
        appli[i]->end();
    status.clear();
}

vector<vect2> compDroneSweep::getSweepposition() {
    return oldSweepposition;
}

void compDroneSweep::setrItfGeoDataSweep(ItfGeoDataInterface* arItfGeoDataSweep) {
    for (DroneSweep* obj : appli)
        obj->setrItfGeoDataSweep(arItfGeoDataSweep);
}

void compDroneSweep::setrItfManageSimSweep(ItfManageSimInterface* arItfManageSimSweep) {
    for (DroneSweep* obj : appli)
        obj->setrItfManageSimSweep(arItfManageSimSweep);
}

void compDroneSweep::setrItfSimDataSweep(ItfSimDataInterface* arItfSimDataSweep) {
    for (DroneSweep* obj : appli)
        obj->setrItfSimDataSweep(arItfSimDataSweep);
}

vector<DroneSweep*> compDroneSweep::getAppli() {
    return appli;
}

// +++++++++++++ Access for minSpeed parameter +++++++++++++
double compDroneSweep::getMinSpeed() {
    return appli[0]->getMinSpeed();
}

void compDroneSweep::setMinSpeed(double arg) {
    for (DroneSweep* obj : appli)
        obj->setMinSpeed(arg);
}

// +++++++++++++ Access for minSpeed parameter +++++++++++++
double compDroneSweep::getMaxSpeed() {
    return appli[0]->getMaxSpeed();
}

void compDroneSweep::setMaxSpeed(double arg) {
    for (DroneSweep* obj : appli)
        obj->setMaxSpeed(arg);
}

// +++++++++++++ Access for visionRadius parameter +++++++++++++
double compDroneSweep::getVisionRadius() {
    return appli[0]->getVisionRadius();
}

void compDroneSweep::setVisionRadius(double arg) {
    for (DroneSweep* obj : appli)
        obj->setVisionRadius(arg);
}

// +++++++++++++ Access for sweepHeight parameter +++++++++++++
double compDroneSweep::getSweepHeight() {
    return appli[0]->getSweepHeight();
}

void compDroneSweep::setSweepHeight(double arg) {
    for (DroneSweep* obj : appli)
        obj->setSweepHeight(arg);
}

// +++++++++++++ Access for batteryCapacity parameter +++++++++++++
double compDroneSweep::getBatteryCapacity() {
    return appli[0]->getBatteryCapacity();
}

void compDroneSweep::setBatteryCapacity(double arg) {
    for (DroneSweep* obj : appli)
        obj->setBatteryCapacity(arg);
}

// +++++++++++++ Access for numberOf parameter +++++++++++++
long compDroneSweep::getNumberOf() {
    return appli[0]->getNumberOf();
}

void compDroneSweep::setNumberOf(long arg) {
    updateNumberOfInstances(arg);
    for (DroneSweep* obj : appli)
        obj->setNumberOf(arg);
}

// +++++++++++++ Access for startingPoint parameter +++++++++++++
vect2 compDroneSweep::getStartingPoint() {
    return appli[0]->getStartingPoint();
}

void compDroneSweep::setStartingPoint(vect2 arg) {
    for (DroneSweep* obj : appli)
        obj->setStartingPoint(arg);
}

// +++++++++++++ Access for collisionRadius parameter +++++++++++++
double compDroneSweep::getCollisionRadius() {
    return appli[0]->getCollisionRadius();
}

void compDroneSweep::setCollisionRadius(double arg) {
    for (DroneSweep* obj : appli)
        obj->setCollisionRadius(arg);
}
