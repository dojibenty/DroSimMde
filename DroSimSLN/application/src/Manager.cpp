/*
 * Manager.cpp
 *
 * Generated by Cares generator, written with Acceleo
 * Author: pyp
 */

#include "Manager.h"
#include "compManager.h"
// Start of user code  : Additional imports for Manager
// End of user code


Manager::Manager(compManager *container)	{
		myContainer = container;
// Start of user code  : Implementation of constructor method

// End of user code
	}
Manager::~Manager(){
// Start of user code  : Implementation of destructor method

// End of user code
	}
void Manager::initialize() {
// Start of user code  : Implementation of initialize method
	Zones = AssignZones();
 	
// End of user code
	}

void Manager::end() {
// Start of user code  : Implementation of end method

// End of user code
	}

void Manager::doStep(int nStep) {
// Start of user code  : Implementation of doStep method
		// to implement
// End of user code
	}
	
	
// Start of user code  : Additional methods
 void AssignZone(ADroneSweep droneSweepInst, int zone) {
   droneSweepInst->
 }
 
 void AssignZone(ADroneSpiral droneSpiralInst, int zone) {
   
 }
 
std::vector<std::vector<std::vector<double>>> AManager::CreateZones() {
	int FilledLines = floor((float)NumDrones/(float)ColMax);
	int TotalLines = ceil((float)NumDrones/(float)ColMax);
	int ZonesLastLine = NumDrones - FilledLines * ColMax;
	
	std::vector<std::vector<std::vector<std::vector<double>>>> Zones;

	// Filled lines
	for (int line = 0; line < FilledLines; line++) {
   		std::vector<std::vector<std::vector<double>>> Line;
 		for (int zone = 0; zone < ColMax; zone++) {
   			std::vector<std::vector<double>> Zone;

   			// Top left point
			Zone.push_back({
				EnvSize.X - (EnvSize.X / TotalLines) * line,
				(EnvSize.Y / ColMax) * zone) });

			// Bottom right point
			Zone.push_back({
				EnvSize.X - (EnvSize.X / TotalLines) * (line + 1),
			  	(EnvSize.Y / ColMax) * (zone + 1) });
			
			Line.push_back(Zone);
  		}
  		Zones.push_back(Line);
 	}

   	// Last line if excess zones
   	if (ZonesLastLine != 0) {
   		std::vector<std::vector<std::vector<double>>> Line;
  		for (int zone = 0; zone < ZonesLastLine; zone++) {
    		std::vector<std::vector<double>> Zone;

			// Top left point
			Zone.push_back({
  				EnvSize.X - (EnvSize.X / TotalLines) * FilledLines,
				(EnvSize.Y / ZonesLastLine) * zone)});

 			// Bottom right point
		   Zone.push_back({
			   0,
			   (EnvSize.Y / ZonesLastLine) * (zone + 1)});

 			Line.push_back(Zone);
  		}
  		Zones.push_back(Line);
 	}

    std::vector<std::vector<std::vector<double>>> ZonesList;

    for (const auto& line : Zones)
    for (const std::vector<std::vector<double>>& zone : line)
 		ZonesList.Add(zone);

   return ZonesList;
 }
// End of user code
	

	// +++++++++++++ Access for simSpeed parameter +++++++++++++
double Manager::getSimSpeed() {
		return simSpeed;
	}
	
void Manager::setSimSpeed(double arg) {
		simSpeed = arg;
	}
	// +++++++++++++ Access for sweepNumber parameter +++++++++++++
long Manager::getSweepNumber() {
		return sweepNumber;
	}
	
void Manager::setSweepNumber(long arg) {
		sweepNumber = arg;
	}
	// +++++++++++++ Access for spiralNumber parameter +++++++++++++
long Manager::getSpiralNumber() {
		return spiralNumber;
	}
	
void Manager::setSpiralNumber(long arg) {
		spiralNumber = arg;
	}

