/*
 * DroneSpiral.cpp
 *
 * Generated by Cares generator, written with Acceleo
 * Author: pyp
 */

#include "DroneSpiral.h"
#include "compDroneSpiral.h"
// Start of user code  : Additional imports for DroneSpiral
#include <iostream>
#include "User.h"
#define PI 3.14159265358979323846
// End of user code


DroneSpiral::DroneSpiral(compDroneSpiral* container, int ID) {
    myContainer = container;
    this->ID = ID;
    rItfGeoDataSpiral = 0;
    rItfManageSimSpiral = 0;
    rItfSimDataSpiral = 0;
    // Start of user code  : Implementation of constructor method

    // End of user code
}

DroneSpiral::~DroneSpiral() {
    // Start of user code  : Implementation of destructor method

    // End of user code
}

void DroneSpiral::initialize() {
    isInZone = false;
    wander = 1;
    // Start of user code  : Implementation of initialize method
    assignedZone = rItfManageSimSpiral->grabAssignedZone(ID);
    const auto rescaledZone = wect2(vect2(assignedZone.getV1().getX() - visionRadius, assignedZone.getV1().getY() + visionRadius),
                              vect2(assignedZone.getV2().getX() + visionRadius, assignedZone.getV2().getY() - visionRadius));
    assignedZone = rescaledZone;

    const auto bottomLeftPoint = vect2(assignedZone.getV2().getX(), assignedZone.getV1().getY());
    zoneStartPoint = bottomLeftPoint + startingPoint * bottomLeftPoint;

    direction = zoneStartPoint;
    direction.normalize();

    movementTolerance = rItfSimDataSpiral->grabPositionCorrection();

    battery = batteryCapacity;
    batConsoFactA = 50;
    batConsoFactB = 0.4;
    batteryConsumption = CONSUMPTION(speed);
    // End of user code
}

void DroneSpiral::end() {
    // Start of user code  : Implementation of end method
    cout << ID << " - bat: " << battery << " // " << cpt << " steps\n";
    // End of user code
}

ReturnCode DroneSpiral::doStep(int nStep) {
    // Start of user code  : Implementation of doStep method
    cpt++;

    // Inputs

    // Execute step
    step(objposition,windForce,windDirection);

    // Outputs
    spiralposition = position;

    // Return codes
    using enum CustomCode;

    if (condObjectiveFound())
        return {objective_found};

    if (condLowBattery())
        return {low_battery};

    return {FormalCode::proceed};
    // End of user code
}

void DroneSpiral::step(const vect2& objposition, const double windForce, const vect2& windDirection) {
    move();
    consumeBattery(windForce,windDirection);
}

bool DroneSpiral::condObjectiveFound() {
    return vect2::distance(position, objposition) <= visionRadius;
}

bool DroneSpiral::condLowBattery() {
    if (battery <= 0) {
        battery = 0;
        return true;
    }
    return false;
}

// Start of user code  : Additional methods
void DroneSpiral::move() {
    if (!isInZone)
        if (zoneStartPoint < position) {
            position = zoneStartPoint;
            isInZone = true;
        }
    
    position = setNextPosition();
}

void DroneSpiral::consumeBattery(const double windForce, const vect2& windDirection) {
    const int alignment = direction.alignment(windDirection);
    switch (alignment) {
    case 0: // vent arriere
        batteryConsumption = CONSUMPTION(speed-(windForce*windInfluence));
        break;
    case 1: // vent de cote
        batteryConsumption = CONSUMPTION(speed+(windForce*windInfluence)*0.5);
        break;
    case 2: // vent contraire
        batteryConsumption = CONSUMPTION(speed+(windForce*windInfluence));
        break;
    default:
        break;
    }
    battery -= batteryConsumption;
}

vect2 DroneSpiral::setNextPosition() {
    vect2 nextPosition;

    if (!isInZone) nextPosition = position + direction * speed;
    else if (wander > 0) nextPosition = getRandomDirection();
    else // Making spiral
    {
        currentCirclePointID = currentCirclePointID % nbCirclePoints + 1;
        vect2 CurrentCirclePoint = circlePoints[currentCirclePointID - 1];

        double DistX = CurrentCirclePoint.getX() - currentCircleCenter.getX();
        double DistY = CurrentCirclePoint.getY() - currentCircleCenter.getY();

        // Pick an intermediate point placed between the current circle center and the current circle point selected
        auto IntermediatePoint = vect2(
            currentCircleCenter.getX() + ((DistX / nbCirclePoints) * currentSpiralIncrementFactor),
            currentCircleCenter.getY() + ((DistY / nbCirclePoints) * currentSpiralIncrementFactor));

        if (!concentricCircles) currentSpiralIncrementFactor += spiralIncrementFactor / nbCirclePoints;
        else if (currentCirclePointID == nbCirclePoints) currentSpiralIncrementFactor += spiralIncrementFactor;

        // Can be translated as "if the current intermediate point is equal or is greater than the selected circle point"
        if (currentSpiralIncrementFactor >= nbCirclePoints
            || goesOutOfBounds(IntermediatePoint)) {
            // Go back at the center of the circle
            direction = currentCircleCenter - position;
            wander = wanderSteps + 1;
        }
        else direction = IntermediatePoint - position;

        direction.normalize();
        nextPosition = position + direction * speed;
    }

    return nextPosition;
}

void DroneSpiral::setCircle() {
    circlePoints.clear();

    const double AngleStep = 2.0 * PI / nbCirclePoints;

    for (int i = 0; i < nbCirclePoints; ++i) {
        double Angle = i * AngleStep;
        vect2 Point(
            spiralRadius * cos(Angle),
            spiralRadius * sin(Angle));
        Point = Point + position;
        circlePoints.emplace_back(Point);
    }

    currentCircleCenter = position;
    currentSpiralIncrementFactor = 1;
}

vect2 DroneSpiral::getRandomDirection() {
    vect2 nextPosition;

    do {
        direction = vect2(
            direction.getX() + User::randRange(-1.0f, 1.0f),
            direction.getY() + User::randRange(-1.0f, 1.0f));
        direction.normalize();
        nextPosition = position + direction * speed;
    } while (goesOutOfBounds(nextPosition));

    if (--wander == 0) setCircle();
    return nextPosition;
}

bool DroneSpiral::goesOutOfBounds(vect2 point) {
    return point.getX() < assignedZone.getV2().getX()
        || point.getY() < assignedZone.getV1().getY()
        || point.getX() > assignedZone.getV1().getX()
        || point.getY() > assignedZone.getV2().getY();
}

// End of user code


void DroneSpiral::setObjposition(vect2 arg) {
    objposition = arg;
}

void DroneSpiral::setWindForce(double arg) {
    windForce = arg;
}

void DroneSpiral::setWindDirection(vect2 arg) {
    windDirection = arg;
}

vect2 DroneSpiral::getSpiralposition() {
    return spiralposition;
}

void DroneSpiral::setrItfGeoDataSpiral(ItfGeoDataInterface* arItfGeoDataSpiral) {
    rItfGeoDataSpiral = arItfGeoDataSpiral;
}

void DroneSpiral::setrItfManageSimSpiral(ItfManageSimInterface* arItfManageSimSpiral) {
    rItfManageSimSpiral = arItfManageSimSpiral;
}

void DroneSpiral::setrItfSimDataSpiral(ItfSimDataInterface* arItfSimDataSpiral) {
    rItfSimDataSpiral = arItfSimDataSpiral;
}

// +++++++++++++ Access for minSpeed parameter +++++++++++++
double DroneSpiral::getMinSpeed() {
    return minSpeed;
}

void DroneSpiral::setMinSpeed(double arg) {
    minSpeed = arg;
}

// +++++++++++++ Access for minSpeed parameter +++++++++++++
double DroneSpiral::getMaxSpeed() {
    return maxSpeed;
}

void DroneSpiral::setMaxSpeed(double arg) {
    maxSpeed = arg;
}

// +++++++++++++ Access for visionRadius parameter +++++++++++++
double DroneSpiral::getVisionRadius() {
    return visionRadius;
}

void DroneSpiral::setVisionRadius(double arg) {
    visionRadius = arg;
}

// +++++++++++++ Access for spiralRadius parameter +++++++++++++
double DroneSpiral::getSpiralRadius() {
    return spiralRadius;
}

void DroneSpiral::setSpiralRadius(double arg) {
    spiralRadius = arg;
}

// +++++++++++++ Access for concentricCircles parameter +++++++++++++
bool DroneSpiral::getConcentricCircles() {
    return concentricCircles;
}

void DroneSpiral::setConcentricCircles(bool arg) {
    concentricCircles = arg;
}

// +++++++++++++ Access for nbCirclePoints parameter +++++++++++++
long DroneSpiral::getNbCirclePoints() {
    return nbCirclePoints;
}

void DroneSpiral::setNbCirclePoints(long arg) {
    nbCirclePoints = arg;
}

// +++++++++++++ Access for spiralIncrementFactor parameter +++++++++++++
double DroneSpiral::getSpiralIncrementFactor() {
    return spiralIncrementFactor;
}

void DroneSpiral::setSpiralIncrementFactor(double arg) {
    spiralIncrementFactor = arg;
}

// +++++++++++++ Access for wanderSteps parameter +++++++++++++
long DroneSpiral::getWanderSteps() {
    return wanderSteps;
}

void DroneSpiral::setWanderSteps(long arg) {
    wanderSteps = arg;
}

// +++++++++++++ Access for batteryCapacity parameter +++++++++++++
double DroneSpiral::getBatteryCapacity() {
    return batteryCapacity;
}

void DroneSpiral::setBatteryCapacity(double arg) {
    batteryCapacity = arg;
}

// +++++++++++++ Access for startingPoint parameter +++++++++++++
vect2 DroneSpiral::getStartingPoint() {
    return startingPoint;
}

void DroneSpiral::setStartingPoint(vect2 arg) {
    startingPoint = arg;
}
