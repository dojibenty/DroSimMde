/*
 * GeoZone.cpp
 *
 * Generated by Cares generator, written with Acceleo
 * Author: pyp
 */

#include "GeoZone.h"
#include "compGeoZone.h"
// Start of user code  : Additional imports for GeoZone
// End of user code


GeoZone::GeoZone(compGeoZone* container) {
    myContainer = container;
    // Start of user code  : Implementation of constructor method

    // End of user code
}

GeoZone::~GeoZone() {
    // Start of user code  : Implementation of destructor method

    // End of user code
}

void GeoZone::initialize() {
    // Start of user code  : Implementation of initialize method
    Zones = CreateZones();
    // End of user code
}

void GeoZone::end() {
    // Start of user code  : Implementation of end method

    // End of user code
}

void GeoZone::doStep(int nStep) {
    // Start of user code  : Implementation of doStep method
    // to implement
    // End of user code
}

// +++++++++++++ Methods of the pItfGeoData interface +++++++++++++
vect2 GeoZone::grabEnvLimits() {
    // Start of user code  : Implementation of method grabEnvLimits
    return envSize;
    // End of user code
}

wect2 GeoZone::grabAssignedZone(long droneID) {
    // Start of user code  : Implementation of method grabAssignedZone
    return Zones[droneID];
    // End of user code
}


// Start of user code  : Additional methods
std::vector<wect2> GeoZone::CreateZones() {
    int NumDrones = droneCount;

    int FilledLines = (int)floor((float)NumDrones / (float)maxInlineZones);
    int TotalLines = (int)ceil((float)NumDrones / (float)maxInlineZones);
    int ZonesLastLine = NumDrones - FilledLines * maxInlineZones;

    std::vector<std::vector<wect2>> Zones;

    // Filled lines
    for (int line = 0; line < FilledLines; line++) {
        std::vector<wect2> Line;
        for (int zone = 0; zone < maxInlineZones; zone++) {
            wect2 Zone;

            // Top left point
            Zone.setV1({
                envSize.getX() - (envSize.getX() / TotalLines) * line,
                (envSize.getY() / maxInlineZones) * zone
            });

            // Bottom right point
            Zone.setV2({
                envSize.getX() - (envSize.getX() / TotalLines) * (line + 1),
                (envSize.getY() / maxInlineZones) * (zone + 1)
            });

            Line.push_back(Zone);
        }
        Zones.push_back(Line);
    }

    // Last line if excess zones
    if (ZonesLastLine != 0) {
        std::vector<wect2> Line;
        for (int zone = 0; zone < ZonesLastLine; zone++) {
            wect2 Zone;

            // Top left point
            Zone.setV1({
                envSize.getX() - (envSize.getX() / TotalLines) * FilledLines,
                (envSize.getY() / ZonesLastLine) * zone
            });

            // Bottom right point
            Zone.setV2({
                0,
                (envSize.getY() / ZonesLastLine) * (zone + 1)
            });

            Line.push_back(Zone);
        }
        Zones.push_back(Line);
    }

    std::vector<wect2> ZonesList;

    for (const auto& line : Zones)
        for (const wect2& zone : line)
            ZonesList.push_back(zone);

    return ZonesList;
}

// End of user code


// +++++++++++++ Access for envSize parameter +++++++++++++
vect2 GeoZone::getEnvSize() {
    return envSize;
}

void GeoZone::setEnvSize(vect2 arg) {
    envSize = arg;
}

// +++++++++++++ Access for maxInlineZones parameter +++++++++++++
long GeoZone::getMaxInlineZones() {
    return maxInlineZones;
}

void GeoZone::setMaxInlineZones(long arg) {
    maxInlineZones = arg;
}

// +++++++++++++ Access for droneCount parameter +++++++++++++
long GeoZone::getDroneCount() {
    return droneCount;
}

void GeoZone::setDroneCount(long arg) {
    droneCount = arg;
}
