/*
 * GeoZone.cpp
 *
 * Generated by Cares generator, written with Acceleo
 * Author: pyp
 */

#include "GeoZone.h"
#include "compGeoZone.h"
// Start of user code  : Additional imports for GeoZone
// End of user code


GeoZone::GeoZone(compGeoZone* container) {
    myContainer = container;
    // Start of user code  : Implementation of constructor method

    // End of user code
}

GeoZone::~GeoZone() {
    // Start of user code  : Implementation of destructor method

    // End of user code
}

void GeoZone::initialize() {
    // Start of user code  : Implementation of initialize method
    Zones = CreateZones();
    // End of user code
}

void GeoZone::end() {
    // Start of user code  : Implementation of end method

    // End of user code
}

int GeoZone::doStep(int nStep) {
    // Start of user code  : Implementation of doStep method
    return 0;
    // End of user code
}

// +++++++++++++ Methods of the pItfGeoData interface +++++++++++++
vect2 GeoZone::grabEnvLimits() {
    // Start of user code  : Implementation of method grabEnvLimits
    return envSize /*+ bottomLeftPoint*/;
    // End of user code
}

wect2 GeoZone::grabAssignedZone(long droneID) {
    // Start of user code  : Implementation of method grabAssignedZone
    return Zones[droneID];
    // End of user code
}


// Start of user code  : Additional methods
vector<wect2> GeoZone::CreateZones() {
    const int FilledLines = (int)floor((float)droneCount / (float)maxInlineZones);
    const int TotalLines = (int)ceil((float)droneCount / (float)maxInlineZones);
    const int ZonesLastLine = droneCount - FilledLines * maxInlineZones;

    vector<vector<wect2>> LocalZones;

    // Filled lines
    for (int line = 0; line < FilledLines; line++) {
        vector<wect2> Line;
        for (int zone = 0; zone < maxInlineZones; zone++) {
            wect2 Zone;

            // Top left point
            Zone.setV1({
                envSize.getX() - (envSize.getX() / TotalLines) * line,
                (envSize.getY() / maxInlineZones) * zone
            });

            // Bottom right point
            Zone.setV2({
                envSize.getX() - (envSize.getX() / TotalLines) * (line + 1),
                (envSize.getY() / maxInlineZones) * (zone + 1)
            });

            Line.push_back(Zone);
        }
        LocalZones.push_back(Line);
    }

    // Last line if excess zones
    if (ZonesLastLine != 0) {
        vector<wect2> Line;
        for (int zone = 0; zone < ZonesLastLine; zone++) {
            wect2 Zone;

            // Top left point
            Zone.setV1({
                envSize.getX() - (envSize.getX() / TotalLines) * FilledLines,
                (envSize.getY() / ZonesLastLine) * zone
            });

            // Bottom right point
            Zone.setV2({
                0,
                (envSize.getY() / ZonesLastLine) * (zone + 1)
            });

            Line.push_back(Zone);
        }
        LocalZones.push_back(Line);
    }

    vector<wect2> ZonesList;

    for (const auto& line : LocalZones)
        for (const wect2& zone : line)
            ZonesList.push_back(zone /*+ bottomLeftPoint*/);

    return ZonesList;
}

// +++++++++++++ Access for droneCount attribute +++++++++++++
long GeoZone::getDroneCount() {
    return droneCount;
}

void GeoZone::setDroneCount(long arg) {
    droneCount = arg;
}
// End of user code


// +++++++++++++ Access for envSize parameter +++++++++++++
vect2 GeoZone::getEnvSize() {
    return envSize;
}

void GeoZone::setEnvSize(vect2 arg) {
    envSize = arg;
}

// +++++++++++++ Access for maxInlineZones parameter +++++++++++++
long GeoZone::getMaxInlineZones() {
    return maxInlineZones;
}

void GeoZone::setMaxInlineZones(long arg) {
    maxInlineZones = arg;
}

// +++++++++++++ Access for bottomLeftPoint parameter +++++++++++++
vect2 GeoZone::getBottomLeftPoint() {
    return bottomLeftPoint;
}

void GeoZone::setBottomLeftPoint(vect2 arg) {
    bottomLeftPoint = arg;
}