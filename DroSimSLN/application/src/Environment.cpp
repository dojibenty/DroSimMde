/*
 * Environment.cpp
 *
 * Generated by Cares generator, written with Acceleo
 * Author: pyp
 */

#include "Environment.h"
#include "compEnvironment.h"
// Start of user code  : Additional imports for Environment
// End of user code


Environment::Environment(compEnvironment *container)	{
		myContainer = container;
// Start of user code  : Implementation of constructor method

    // End of user code
	}
Environment::~Environment(){
// Start of user code  : Implementation of destructor method

    // End of user code
	}
void Environment::initialize() {
// Start of user code  : Implementation of initialize method
Zones = CreateZones();
    // End of user code
	}

void Environment::end() {
// Start of user code  : Implementation of end method

    // End of user code
	}

void Environment::doStep(int nStep) {
// Start of user code  : Implementation of doStep method
    // to implement
    // End of user code
	}
	
	// +++++++++++++ Methods of the pItfEnvironment interface +++++++++++++
vect2 Environment::getEnvLimits(){
// Start of user code  : Implementation of method getEnvLimits
    return envSize;
    // End of user code
	}

wect2 Environment::getAssignedZone(long ID){
// Start of user code  : Implementation of method getAssignedZone
    return Zones[ID];
    // End of user code
	}

	
// Start of user code  : Additional methods
std::vector<wect2> Environment::CreateZones() {
	int NumDrones = sweepNumber + spiralNumber;
	
	int FilledLines = (int)floor((float)NumDrones/(float)maxInlineZones);
	int TotalLines = (int)ceil((float)NumDrones/(float)maxInlineZones);
	int ZonesLastLine = NumDrones - FilledLines * maxInlineZones;
	
	std::vector<std::vector<wect2>> Zones;

	// Filled lines
	for (int line = 0; line < FilledLines; line++) {
		std::vector<wect2> Line;
		for (int zone = 0; zone < maxInlineZones; zone++) {
			wect2 Zone;

			// Top left point
			Zone.setV1({
				envSize.getX() - (envSize.getX() / TotalLines) * line,
				(envSize.getY() / maxInlineZones) * zone });

			// Bottom right point
			Zone.setV2({
				envSize.getX() - (envSize.getX() / TotalLines) * (line + 1),
				  (envSize.getY() / maxInlineZones) * (zone + 1) });
			
			Line.push_back(Zone);
		}
		Zones.push_back(Line);
	}

	// Last line if excess zones
	if (ZonesLastLine != 0) {
		std::vector<wect2> Line;
		for (int zone = 0; zone < ZonesLastLine; zone++) {
			wect2 Zone;

			// Top left point
			Zone.setV1({
				  envSize.getX() - (envSize.getX() / TotalLines) * FilledLines,
				(envSize.getY() / ZonesLastLine) * zone });

			// Bottom right point
			Zone.setV2({
				0,
				(envSize.getY() / ZonesLastLine) * (zone + 1) });

			Line.push_back(Zone);
		}
		Zones.push_back(Line);
	}

	std::vector<wect2> ZonesList;

	for (const auto& line : Zones)
		for (const wect2& zone : line)
			ZonesList.push_back(zone);

	return ZonesList;
}
// End of user code
	

	// +++++++++++++ Access for envSize parameter +++++++++++++
vect2 Environment::getEnvSize() {
		return envSize;
	}
	
void Environment::setEnvSize(vect2 arg) {
		envSize = arg;
	}
	// +++++++++++++ Access for maxInlineZones parameter +++++++++++++
long Environment::getMaxInlineZones() {
		return maxInlineZones;
	}
	
void Environment::setMaxInlineZones(long arg) {
		maxInlineZones = arg;
	}
	// +++++++++++++ Access for sweepNumber parameter +++++++++++++
long Environment::getSweepNumber() {
		return sweepNumber;
	}
	
void Environment::setSweepNumber(long arg) {
		sweepNumber = arg;
	}
	// +++++++++++++ Access for spiralNumber parameter +++++++++++++
long Environment::getSpiralNumber() {
		return spiralNumber;
	}
	
void Environment::setSpiralNumber(long arg) {
		spiralNumber = arg;
	}

