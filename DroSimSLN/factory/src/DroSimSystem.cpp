/* 
 * DroSimSystem.cpp
 * Root Component
 *
 * Generated by Cares generator, written with Acceleo
 * Author: pyp
 */
#include "DroSimSystem.h"
#include "Simulation.h"
#include "Wind.h"
#include "User.h"
#include "GeoZone.h"

ASimulation* DroSimSystem::get_ASimulation() {
    return instASimulation;
}

AWind* DroSimSystem::get_AWind() {
    return instAWind;
}

AUser* DroSimSystem::get_AUser() {
    return instAUser;
}

AGeoZone* DroSimSystem::get_AGeoZone() {
    return instAGeoZone;
}

AObjective* DroSimSystem::get_AObjective() {
    return instAObjective;
}

vector<ADroneSweep*> DroSimSystem::get_ADroneSweep() {
    return instADroneSweep;
}

vector<ADroneSpiral*> DroSimSystem::get_ADroneSpiral() {
    return instADroneSpiral;
}

DroSimSystem::DroSimSystem() {
    client_ = new Client("system");
    
    // Simulation
    instASimulation = new ASimulation(1.0);
    leafComponents.push_back(instASimulation);
    instASimulation->setSystemRef(this);

    // Wind
    instAWind = new AWind(1.0);
    leafComponents.push_back(instAWind);
    instAWind->setSystemRef(this);

    // User
    instAUser = new AUser(1.0);
    leafComponents.push_back(instAUser);
    instAUser->setSystemRef(this);

    // GeoZone
    instAGeoZone = new AGeoZone(1.0);
    leafComponents.push_back(instAGeoZone);
    instAGeoZone->setSystemRef(this);

    // Objective
    instAObjective = new AObjective(1.0);
    leafComponents.push_back(instAObjective);
    instAObjective->setSystemRef(this);

    instAUser->setrItfGeoDataUser(instAGeoZone->getAppli());
    instAObjective->setrItfGeoDataObj(instAGeoZone->getAppli());

    // TODO => parametres mutables
    // Initialisation des mutables
    minSpeed = 10.0;
    maxSpeed = 30.0;
    mutableSpeed = 10.0;
    maxNumberOfDrones = 10;
    speedIncrement = 2.0;
    numberOfDroneSweepIncrement = 1;
    numberOfDroneSpiralIncrement = 1;
}

DroSimSystem::~DroSimSystem() {}

void DroSimSystem::initialize() {
    // Simulation
    instASimulation->setExpectedEndTime(300000.0);
    instASimulation->setPositionCorrection(1.0);

    // Wind
    instAWind->setForce(0.0);
    instAWind->setDirection(vect2(0.5, 0.5));

    // User

    // GeoZone
    instAGeoZone->setEnvSize(vect2(20000.0, 20000.0));
    instAGeoZone->setBottomLeftPoint(vect2(45.0, -5.0));

    // Objective
    instAObjective->setSpeedConstraint(0.0);
    instAObjective->setPosition(vect2(0, 0));

    int idx = 0;
    
    // DroneSweep
    for (int i = 0; i < mutableNumberOfDroneSweep; i++, idx++) {
        const auto inst = new ADroneSweep(10.0,idx);
        inst->setMinSpeed(10.0);
        inst->setMaxSpeed(30.0);
        inst->setVisionRadius(1000.0);
        inst->setSweepHeight(2000.0);
        inst->setBatteryCapacity(200.0);
        inst->setCollisionRadius(5.0);
        inst->setStartingPoint(vect2(0.0, 0.0));
        inst->setSpeed(mutableSpeed);
        inst->setAObjective(instAObjective);
        inst->setAWind(instAWind);
        inst->setrItfManageSimSweep(instAUser->getAppli());
        inst->setrItfGeoDataSweep(instAGeoZone->getAppli());
        inst->setrItfSimDataSweep(instASimulation->getAppli());
        instADroneSweep.emplace_back(inst);
        leafComponents.push_back(inst);
        inst->setSystemRef(this);
    }

    // DroneSpiral
    for (int i = 0; i < mutableNumberOfDroneSpiral; i++, idx++) {
        const auto inst = new ADroneSpiral(10.0,idx);
        inst->setMinSpeed(10.0);
        inst->setMaxSpeed(30.0);
        inst->setVisionRadius(1000.0);
        inst->setSpiralRadius(2000.0);
        inst->setConcentricCircles(false);
        inst->setNbCirclePoints(8);
        inst->setSpiralIncrementFactor(3);
        inst->setWanderSteps(5);
        inst->setBatteryCapacity(200.0);
        inst->setCollisionRadius(5.0);
        inst->setStartingPoint(vect2(0.5, 0.5));
        inst->setSpeed(mutableSpeed);
        inst->setAObjective(instAObjective);
        inst->setAWind(instAWind);
        inst->setrItfManageSimSpiral(instAUser->getAppli());
        inst->setrItfGeoDataSpiral(instAGeoZone->getAppli());
        inst->setrItfSimDataSpiral(instASimulation->getAppli());
        instADroneSpiral.emplace_back(inst);
        leafComponents.push_back(inst);
        inst->setSystemRef(this);
    }
    
    // Calcultated attributes
    instAUser->setDroneCount(mutableNumberOfDroneSweep + mutableNumberOfDroneSpiral);

    // Initialization
    if (instASimulation->getIsActive()) instASimulation->initialize();
    if (instAWind->getIsActive()) instAWind->initialize();
    if (instAUser->getIsActive()) instAUser->initialize();
    if (instAGeoZone->getIsActive()) instAGeoZone->initialize();
    if (instAObjective->getIsActive()) instAObjective->initialize();
    for (const auto& inst : instADroneSweep)
        if (inst->getIsActive()) inst->initialize();
    for (const auto& inst : instADroneSpiral)
        if (inst->getIsActive()) inst->initialize();
    // Start of user code  : Implementation of initialize method DroSimSystem
    // End of user code
}

void DroSimSystem::end() {
    message_ = "";
    instASimulation->end();
    instAWind->end();
    instAUser->end();
    instAGeoZone->end();
    instAObjective->end();
    for (const auto& inst : instADroneSweep) inst->end();
    instADroneSweep.clear();
    for (const auto& inst : instADroneSpiral) inst->end();
    instADroneSpiral.clear();
    for (int i = 0; i < leafComponents.size(); i++) {
        ObjectCode oc = leafComponents[i]->getObjectCode();
        if (oc == objDroneSweep || oc == objDroneSpiral)
            leafComponents.erase(leafComponents.begin() + i);
    }
    // Start of user code  : Implementation of end method DroSimSystem
    // End of user code
}

void DroSimSystem::mutateParameters(const bool isGroupSuccessful, const double averageTimeToFind) {
    cout << (isGroupSuccessful ? "Success" : "Fail") << endl;

    if (isGroupSuccessful) cout << "Average of " << (int)(averageTimeToFind / 1000 / 60 * 10) << " min to find\n";

    const double cSpeed = mutableSpeed;
    const int cNumberOfDroneSweep = mutableNumberOfDroneSweep;
    const int cNumberOfDroneSpiral = mutableNumberOfDroneSpiral;
    
    if (!isCurveFound || isGroupSuccessful) {
        // We overwrite the saved config as we don't need it right now
        pSpeed = cSpeed;
    }

    if (isCurveFound && isMaxFound) {
        if (isGroupSuccessful && cSpeed - speedIncrement >= minSpeed)
            mutableSpeed -= speedIncrement;
        else {
            slowConfigs.emplace_back(pSpeed, cNumberOfDroneSweep, cNumberOfDroneSpiral);

            if (cNumberOfDroneSpiral > cNumberOfDroneSweep)
                mutableNumberOfDroneSweep += numberOfDroneSweepIncrement;
            else mutableNumberOfDroneSpiral += numberOfDroneSpiralIncrement;

            // We save the current config for later comparison
            pSpeed = cSpeed;
        }
    }
    else {
        if (!isCurveFound && isGroupSuccessful) {
            // Found the first valid configuration
            slowConfigs.emplace_back(cSpeed, cNumberOfDroneSweep, cNumberOfDroneSpiral);
            isCurveFound = true;
            cout << "Curve found" << '\n';
        }
        if (cSpeed + speedIncrement <= maxSpeed)
            mutableSpeed += speedIncrement;
        else if (isCurveFound) {
            // Found the maximum speed drones need to go at
            fastConfig = make_tuple(cSpeed, cNumberOfDroneSweep, cNumberOfDroneSpiral);
            isMaxFound = true;
            cout << "Max speed found" << '\n';
            if (cNumberOfDroneSpiral > cNumberOfDroneSweep)
                mutableNumberOfDroneSweep += numberOfDroneSweepIncrement;
            else mutableNumberOfDroneSpiral += numberOfDroneSpiralIncrement;
            mutableSpeed = get<0>(slowConfigs[0]);
        }
        else {
            if (cNumberOfDroneSpiral > cNumberOfDroneSweep)
                mutableNumberOfDroneSweep += numberOfDroneSweepIncrement;
            else mutableNumberOfDroneSpiral += numberOfDroneSpiralIncrement;
            mutableSpeed = minSpeed;
        }
    }
    
    cout << "Trying with " << mutableNumberOfDroneSweep
    << " drone" << (mutableNumberOfDroneSweep > 1 ? "s" : "") << " making sweeps and "
    << mutableNumberOfDroneSpiral << " drone" << (mutableNumberOfDroneSpiral > 1 ? "s" : "") << " making spirals" 
    << " at " << mutableSpeed << " m/s\n";
}

bool DroSimSystem::continueCondition() const {
    return mutableNumberOfDroneSweep + mutableNumberOfDroneSpiral <= maxNumberOfDrones;
}

vector<tuple<double,int,int>> DroSimSystem::getSlowConfigs() {
    return slowConfigs;
}

tuple<double,int,int> DroSimSystem::getFastConfig() {
    return fastConfig;
}

void DroSimSystem::AddToMessage(const std::string& identifier) {
    if (message_.length() != 0) message_ += ',';
    message_ += identifier;
}

/*
void DroSimSystem::AddToMessage(const std::string& identifier, const std::string& varType, const std::string& varName) {
    if (message_.length() == 0) message_ += ',';
    message_ += identifier;
}
*/

int DroSimSystem::SendRequestMessage() const {
    const int ok = client_->sendToServer(message_);
    return ok;
}

void DroSimSystem::GetResponse() const {
    const string res = client_->waitResponse();
    if (res.length() == 0) return;
    std::cout << res << '\n';
}