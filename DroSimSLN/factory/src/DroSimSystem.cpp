/* 
 * DroSimSystem.cpp
 * Root Component
 *
 * Generated by Cares generator, written with Acceleo
 * Author: pyp
 */
#include "DroSimSystem.h"
#include "Simulation.h"
#include "Wind.h"
#include "User.h"
#include "GeoZone.h"

ASimulation* DroSimSystem::get_ASimulation() {
    return instASimulation;
}

AWind* DroSimSystem::get_AWind() {
    return instAWind;
}

AUser* DroSimSystem::get_AUser() {
    return instAUser;
}

AGeoZone* DroSimSystem::get_AGeoZone() {
    return instAGeoZone;
}

AObjective* DroSimSystem::get_AObjective() {
    return instAObjective;
}

vector<ADroneSweep*> DroSimSystem::get_ADroneSweep() {
    return instADroneSweep;
}

vector<ADroneSpiral*> DroSimSystem::get_ADroneSpiral() {
    return instADroneSpiral;
}

DroSimSystem::DroSimSystem() {
    // Simulation
    instASimulation = new ASimulation(1.0);
    leafComponents.push_back(instASimulation);

    // Wind
    instAWind = new AWind(1.0);
    leafComponents.push_back(instAWind);

    // User
    instAUser = new AUser(1.0);
    leafComponents.push_back(instAUser);

    // GeoZone
    instAGeoZone = new AGeoZone(1.0);
    leafComponents.push_back(instAGeoZone);

    // Objective
    instAObjective = new AObjective(1.0);
    leafComponents.push_back(instAObjective);

    instAUser->setrItfGeoDataUser(instAGeoZone->getAppli());
    instAObjective->setrItfGeoDataObj(instAGeoZone->getAppli());

    // TODO => parametres mutables
    // Initialisation des mutables
    minSpeed = 10.0;
    maxSpeed = 30.0;
    mutableSpeed = 10.0;
    maxNumberOfDroneSweep = 8;
    speedIncrement = 2.0;
    numberOfDroneSweepIncrement = 1;
}

DroSimSystem::~DroSimSystem() {}

void DroSimSystem::initialize() {
    // Simulation
    instASimulation->setExpectedEndTime(300000.0);
    instASimulation->setPositionCorrection(1.0);

    // Wind
    instAWind->setForce(0.0);
    instAWind->setDirection(vect2(0.5, 0.5));

    // User

    // GeoZone
    instAGeoZone->setEnvSize(vect2(20000.0, 20000.0));
    instAGeoZone->setBottomLeftPoint(vect2(45.0, -5.0));

    // Objective
    instAObjective->setSpeedConstraint(0.0);
    instAObjective->setPosition(vect2(0, 0));

    // DroneSweep
    for (int i = 0; i < mutableNumberOfDroneSweep; i++) {
        const auto inst = new ADroneSweep(10.0,i);
        inst->setMinSpeed(10.0);
        inst->setMaxSpeed(30.0);
        inst->setVisionRadius(1000.0);
        inst->setSweepHeight(2000.0);
        inst->setBatteryCapacity(200.0);
        inst->setCollisionRadius(5.0);
        inst->setStartingPoint(vect2(0.0, 0.0));
        inst->setSpeed(mutableSpeed);
        inst->setAObjective(instAObjective);
        inst->setAWind(instAWind);
        inst->setrItfManageSimSweep(instAUser->getAppli());
        inst->setrItfGeoDataSweep(instAGeoZone->getAppli());
        inst->setrItfSimDataSweep(instASimulation->getAppli());
        instADroneSweep.emplace_back(inst);
        leafComponents.push_back(inst);
    }

    // DroneSpiral
    for (int i = 0; i < numberOfDroneSpiral; i++) {
        const auto inst = new ADroneSpiral(10.0,i);
        inst->setMinSpeed(10.0);
        inst->setMaxSpeed(30.0);
        inst->setVisionRadius(1000.0);
        inst->setSpiralRadius(2000.0);
        inst->setConcentricCircles(false);
        inst->setNbCirclePoints(8);
        inst->setSpiralIncrementFactor(3);
        inst->setWanderSteps(5);
        inst->setBatteryCapacity(200.0);
        inst->setStartingPoint(vect2(0.5, 0.5));
        inst->setAObjective(instAObjective);
        inst->setAWind(instAWind);
        inst->setrItfManageSimSpiral(instAUser->getAppli());
        inst->setrItfGeoDataSpiral(instAGeoZone->getAppli());
        inst->setrItfSimDataSpiral(instASimulation->getAppli());
        instADroneSpiral.emplace_back(inst);
        leafComponents.push_back(inst);
    }
    
    // Calcultated attributes
    instAUser->setDroneCount(mutableNumberOfDroneSweep + numberOfDroneSpiral);

    // Initialization
    if (instASimulation->getIsActive()) instASimulation->initialize();
    if (instAWind->getIsActive()) instAWind->initialize();
    if (instAUser->getIsActive()) instAUser->initialize();
    if (instAGeoZone->getIsActive()) instAGeoZone->initialize();
    if (instAObjective->getIsActive()) instAObjective->initialize();
    for (const auto& inst : instADroneSweep)
        if (inst->getIsActive()) inst->initialize();
    for (const auto& inst : instADroneSpiral)
        if (inst->getIsActive()) inst->initialize();
    // Start of user code  : Implementation of initialize method DroSimSystem
    // End of user code
}

void DroSimSystem::end() {
    instASimulation->end();
    instAWind->end();
    instAUser->end();
    instAGeoZone->end();
    instAObjective->end();
    for (const auto& inst : instADroneSweep) inst->end();
    instADroneSweep.clear();
    for (const auto& inst : instADroneSpiral) inst->end();
    instADroneSpiral.clear();
    for (int i = 0; i < leafComponents.size(); i++) {
        ObjectCode oc = leafComponents[i]->getObjectCode();
        if (oc == objDroneSweep || oc == objDroneSpiral)
            leafComponents.erase(leafComponents.begin() + i);
    }
    // Start of user code  : Implementation of end method DroSimSystem
    // End of user code
}

void DroSimSystem::mutateParameters(const bool isGroupSuccessful, const double averageTimeToFind) {
    cout << (isGroupSuccessful ? "Success" : "Fail") << endl;

    if (isGroupSuccessful) cout << "Average of " << (int)(averageTimeToFind / 1000 / 60 * 10) << " min to find\n";

    const double cSpeed = mutableSpeed;
    const int cNumberOf = mutableNumberOfDroneSweep;
    const double cBatCap = 200.0;
    
    if (!isCurveFound || isGroupSuccessful) {
        // We overwrite the saved config as we don't need it right now
        pSpeed = cSpeed;
        pBatCap = cBatCap;
    }

    if (isCurveFound && isMaxFound) {
        if (isGroupSuccessful && cSpeed - speedIncrement >= minSpeed)
            mutableSpeed -= speedIncrement;
        else {
            slowConfigs.emplace_back(pSpeed, cNumberOf, pBatCap);
            
            mutableNumberOfDroneSweep += numberOfDroneSweepIncrement;

            // We save the current config for later comparison
            pSpeed = cSpeed;
        }
    }
    else {
        if (!isCurveFound && isGroupSuccessful) {
            // Found the first valid configuration
            slowConfigs.emplace_back(cSpeed, cNumberOf, cBatCap);
            isCurveFound = true;
            cout << "Curve found" << '\n';
        }
        if (cSpeed + speedIncrement <= maxSpeed)
            mutableSpeed += speedIncrement;
        else if (isCurveFound) {
            // Found the maximum speed drones need to go at
            fastConfig = make_tuple(cSpeed, cNumberOf, cBatCap);
            isMaxFound = true;
            cout << "Max speed found" << '\n';
            mutableNumberOfDroneSweep += numberOfDroneSweepIncrement;
            mutableSpeed = get<0>(slowConfigs[0]);
        }
        else {
            mutableNumberOfDroneSweep += numberOfDroneSweepIncrement;
            mutableSpeed = minSpeed;
        }
    }
    
    cout << "Trying with " << mutableNumberOfDroneSweep
    << " drone" << (mutableNumberOfDroneSweep > 1 ? "s" : "")
    << " at " << mutableSpeed << " m/s\n";
}

double DroSimSystem::calculateBatteryCapForGroup(const double averageTimeToFind) const {
    return averageTimeToFind / 1000.0 * 10.0 / 60.0 / 60.0 * pow(instADroneSweep[0]->getSpeed(), 2) * 2.0;
}

bool DroSimSystem::continueCondition() const {
    return mutableNumberOfDroneSweep <= maxNumberOfDroneSweep;
}

vector<tuple<double,int,int>> DroSimSystem::getSlowConfigs() {
    return slowConfigs;
}

tuple<double,int,int> DroSimSystem::getFastConfig() {
    return fastConfig;
}